<div align="right">
<b>Author:</b> Tutkabay Assem<br>
<b>University:</b> Astana IT University
</div>

# KMP Report




# KMP String Matching Algorithm – Implementation Report

## 1. Overview

This project implements the Knuth–Morris–Pratt (KMP) string matching algorithm in Java.  
The goal is to efficiently search for all occurrences of a pattern string inside a larger text string, while avoiding unnecessary re-checks of characters.

Key features:

- Clean KMP implementation (`KMPMatcher`)
- Maven project structure
- JSON-driven input for test cases (`cases.json`)
- JUnit 5 tests that reuse the same JSON input
- Output of results to `output.json` in `src/main/resources`

---

## 2. Algorithm Description

### 2.1. Problem

Given:

- `text` – the main string
- `pattern` – the substring we want to find

We want to find all starting indices `i` such that:

```text
text[i..i + pattern.length - 1] == pattern
```

### 2.2. Idea of KMP

A naive algorithm compares `pattern` at every position in `text`, and when a mismatch happens, it restarts from the next position in the text.  
KMP improves this by using information about the pattern itself and never moving backwards in the text.

Core idea:

1. Precompute an auxiliary array `lps` (Longest Prefix which is also Suffix) for the pattern.
2. When a mismatch occurs after some matches, use `lps` to know the next possible position in the pattern, instead of restarting from index `0`.

### 2.3. LPS Array

For each index `i` in the pattern, `lps[i]` stores the length of the longest proper prefix of the pattern which is also a suffix of the substring `pattern[0..i]`.

Example pattern: `ababaca`

The `lps` array tells us how much of the prefix is still “valid” when a mismatch occurs at position `i`.

This preprocessing allows us to reuse partial matches instead of re-checking characters from scratch.

### 2.4. Search Procedure

Variables:

- `i` – index in `text`
- `j` – index in `pattern`

Algorithm:

1. Compare `text[i]` and `pattern[j]`.
2. If equal, increment both `i` and `j`.
3. If `j` reaches `pattern.length`, we found a match at `i - j`.  
   Add this index to the result and set `j = lps[j - 1]`.
4. If there is a mismatch:
   - If `j != 0`, set `j = lps[j - 1]` (jump inside the pattern).
   - If `j == 0`, increment `i` (move forward in the text).

Special case: if `pattern` is empty (`""`), the implementation returns all positions `0..text.length()`.

---

## 3. Implementation Details

### 3.1. Main Classes

- `KMPMatcher`
  - Constructor: `KMPMatcher(String pattern)`
  - Methods:
    - `List<Integer> searchAll(String text)` – returns all starting indices of matches
    - `int searchFirst(String text)` – returns the first match index or `-1` if none
  - Internal method:
    - `int[] buildLpsArray(String pattern)` – builds the `lps` array

- `InputConfig`
  - Simple data holder that matches the JSON structure:
    ```json
    {
      "cases": [
        {
          "name": "short",
          "pattern": "...",
          "text": "...",
          "expectedMatches": [ ... ]
        }
      ]
    }
    ```

- `Main`
  - Reads `src/main/resources/cases.json`.
  - Runs KMP for each case.
  - Prints results to the console.
  - Writes summarized results to `src/main/resources/output.json`.

### 3.2. JSON Input and Output

**Input file:** `src/main/resources/cases.json`

```json
{
  "cases": [
    {
      "name": "short",
      "pattern": "aba",
      "text": "ababa",
      "expectedMatches": [0, 2]
    },
    {
      "name": "medium",
      "pattern": "test",
      "text": "this is a simple test text to test kmp",
      "expectedMatches": [17, 30]
    },
    {
      "name": "long",
      "pattern": "pattern",
      "text": "this is a very long text used to test the performance of the kmp pattern matching algorithm. the word pattern appears several times in this pattern-rich text to make sure pattern search works even on a longer input. finally, we add one more pattern here.",
      "expectedMatches": [65, 102, 140, 171, 241]
    }
  ]
}
```

**Output file:** `src/main/resources/output.json`  
(Generated by `Main`)

Format:

```json
[
  {
    "case": "short",
    "pattern": "aba",
    "matches": [0, 2]
  },
  {
    "case": "medium",
    "pattern": "test",
    "matches": [17, 30]
  },
  {
    "case": "long",
    "pattern": "pattern",
    "matches": [65, 102, 140, 171, 241]
  }
]
```

---

## 4. Testing

Testing is done in two layers:

1. **Functional testing through `Main`**  
   - Uses `cases.json` as input.
   - Produces `output.json` and console output.

2. **JUnit testing through `KMPMatcherJsonTest`**  
   - Reads the same `cases.json` via the classpath.
   - For each case:
     - Builds `KMPMatcher` with `pattern`.
     - Calls `searchAll(text)`.
     - Asserts that the result equals `expectedMatches`.

Example test: `medium` case

- pattern: `"test"`
- text: `"this is a simple test text to test kmp"`
- expected matches: `[17, 30]`

The test verifies that the indices are correct and that overlapping behavior is right where needed.

---

## 5. Time and Space Complexity

Let:

- `n = text.length()`
- `m = pattern.length()`

### 5.1. Preprocessing (LPS construction)

- We scan the pattern once with two indices.
- Each character in the pattern is processed at most a constant number of times.
- **Time:** `O(m)`
- **Space:** `O(m)` for the `lps` array.

### 5.2. Search Phase

- We scan the text once with index `i`.
- Index `i` never moves backward.
- Index `j` only moves within `0..m`, and each step is amortized constant.
- **Time:** `O(n)`
- **Space:** no additional asymptotic memory usage beyond:
  - the `lps` array `O(m)`
  - the result list (contains at most `O(n)` indices in the worst case).

### 5.3. Overall Complexity

- **Total Time:** `O(n + m)`
- **Total Space:** `O(m + k)`  
  где `k` – количество найденных вхождений.

This meets the requirement for an efficient string matching algorithm and clearly improves on the naive `O(n * m)` approach on long inputs.

---

## 6. Project Structure

Standard Maven structure:

```text
kmp/
├─ pom.xml
├─ src
   ├─ main
   │  ├─ java
   │  │  └─ org/example/kmp
   │  │     ├─ KMPMatcher.java
   │  │     ├─ InputConfig.java
   │  │     └─ Main.java
   │  └─ resources
   │     └─ cases.json
   └─ test
      └─ java
         └─ org/example/kmp
            └─ KMPMatcherJsonTest.java
```

This layout is ready for building, testing, and pushing as a clean GitHub repository.

---

## 7. Conclusion

The project demonstrates:

- A correct and efficient implementation of the KMP algorithm.
- Clear separation between algorithm, configuration, and I/O.
- Automated testing with shared JSON input.
- Realistic behavior on short, medium, and long strings, with verifiable match indices.

This setup is suitable both for educational purposes and as a base for integrating KMP into larger systems where fast substring search is required.
